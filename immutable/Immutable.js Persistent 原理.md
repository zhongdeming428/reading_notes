## Immutable.js Persistent 原理

距离上一次写文章已经过去了五个月，现在终于决定继续沉下心来写一篇比较深入的文章。

这是一篇关于 Immutable.js 的文章，就像标题写的那样，不涉及 Immutable.js 的使用方式，只关注 Immutable.js 实现 persistent 的原理。

文章相关 ppt 和脑图已经上传到 GitHub：[reading_notes](https://github.com/zhongdeming428/reading_notes)，由于时间关系不会像以前那样在文章中进行过于详细的阐述，很多环节可能只讲述实现的基本原理，具体细节可以参考 ppt 和脑图或者源代码。

下面开始进入正题吧！

下图是本篇文章（也是对应 ppt）的内容提要：

![摘要](https://tva1.sinaimg.cn/large/007S8ZIlgy1gixadbs2kaj31140u0ag8.jpg)

### 一 基础介绍

#### 什么是 Immutable？

immutable 代表不可变的数据，即创建之后不可以再修改的数据。对应的有 mutable 数据，在创建之后仍然可以被修改。

#### JavaScript 中的 Immutable

JavaScript 中的所有原始数据类型（primitive value）都是 immutable 的；

JavaScript 中的所有复杂数据类型都是 mutable 的。

比如：

```js
const foo = 'string';
const bar = {};

let foo1 = foo;
const bar1 = bar;

foo1 = 'new-string';
bar1['CUSTOM_VALUE'] = [];

console.log(foo, bar, foo1, bar1);

// 输出：string {CUSTOM_VALUE: Array(0)} new-string {CUSTOM_VALUE: Array(0)}
```

由此可以发现，对于 foo1 的更改不会体现到 foo 上，而对于 bar1 的修改会影响到 bar。

这也可以解释为什么 string 类型可以通过 `[]` 索引字符，但是不可以对其赋值了。

#### Immutable & Mutable

产生 Immutable 和 Mutable 的根本原因在于数据存储方式的不同。对于简单的数据（可以理解为原始类型的数据），占用的存储空间小，操作简单，复制开销小，所以可以直接存储在栈内，每次赋值都可以直接进行值的复制；对于复杂的数据（可以理解为复杂类型的数据），占用的存储空间大，操作更加复杂，复制的时候开销比较大，所以存储在栈外的堆中，栈内只存储相应的指针。

我们在对复杂类型数据进行索引的时候，都是根据栈内存储的指针进行操作的，所以复制复杂类型数据的时候，实际上复制的也只是栈内的指针，两个指针会指向同一片内存区域，共享复杂类型的数据。这样做的好处是减少了操作复杂数据消耗的时间，降低了复制复杂数据所占用的多余空间。

两种类型的数据互有优劣，所以使用那种数据需要根据实际场景进行取舍，并不能说哪种数据就比哪种数据强。

二者的优劣对比如下：

|           | 优点                                                         | 缺点                                   |
| --------- | ------------------------------------------------------------ | -------------------------------------- |
| Mutable   | 充分利用内存，提高运行效率，减少了值复制和内存分配的时间。多数语言原生采用的方式，操作简便，较低学习成本。 | 数据操作更加危险，并发编程更加复杂。   |
| Immutable | 保证并发编程的安全性。 可以实现数据操作的原子性。            | 占用更多内存，操作效率较低，学习成本高 |

#### 为什么使用 Immutable？

上一小节说到需要针对不同的场景考量使用哪种类型的数据，所以这一小节就需要讲一讲为什么需要使用 Immutable 数据？

Immutable 本来就是函数式编程中的一个概念，因为函数式编程强调数据的不可变性和函数的引用透明性，强调函数永远是一个不会修改外部数据的闭合功能单元。这样我们就可以单纯地思考当前函数的功能实现，在使用函数的时候也可以放心的调用它而不用担心它会影响到外部的或者全局的数据导致难以预测的问题。

所以使用 Immutable 数据的出发点就找到了，当我们进行函数式编程且需要尽可能地提高函数的引用透明性时，我们就应该使用 Immutable 类型的数据。这也是为什么 React 中需要使用 Immutable 而 Vue 并不 care。因为 Vue 开发并不遵循函数式编程范式，通过数据劫持和依赖收集可以自动解析到数据的变更，进而对 UI 进行 update。而 React 遵循函数式编程范式，其核心思想就是 `UI = f(state)`，所以我们编写的 React 组件越纯越好。

以上描述可能会比较抽象，所以下面举一个简单的例子：

![react example](https://tva1.sinaimg.cn/large/007S8ZIlgy1gixh3o5jlvj30u01ui10x.jpg)

上面有两个子组件和一个父组件，点击对应的 button 可以更新对应的子属性，但是点击 button 之后，可以看到另一个组件即使数据没有发生变化，也会进行 rerender。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gixhjqjjtzj30u00vzjuo.jpg)

这时候我们就需要使用 React.memo 进行数据对比，向 React.memo 传入比对函数，比对前后数据是否发生变化，就可以阻止子组件在数据未发生变化的时候进行多余的 rerender。而使用 Immutable 数据，可以加快这个比对的过程，这就是为什么需要使用 Immutable 数据。另外在 React 中使用 immutable 还有一个好处就是当我们更改了数据之后，总是会返回一个新的数据对象，而不会在旧的数据上做修改，避免了直接更改旧的 state 而导致 React 无法接收到数据的变更消息。

#### 实际开发中的 Immutable 思想的应用

- 多数语言都已经自身或者通过第三方包实现 Immutable 数据结构。

  JavaScript/Elm/Python/Clojure/Java/...

- React 通过 Immutable 加快比对速度。

- 文件系统的 COW 机制，在复制数据到指定区间的时候，会先将旧的数据拷贝一份，避免意外导致的数据丢失。

### 二 实现方式

实现 Immutable 的方式有很多，下面介绍几种常见的方式。

#### 1 浅拷贝

通过浅拷贝我们就可以实现 Immutable 数据，这个相比大家都知道，因为 React 在官方文档中就介绍过这种方式：

```js
const a = {
  name: 'Russ',
  gender: 1,
  favoriteFoods: ['banana', 'watermelon', 'grape']
};

const b = {
  ...a,
  favoriteFoods: [
    ...a.favoriteFoods,
    'litchi'
  ]
};
```

通过这种方式，我们复用了 a 中的 `name` 和 `gender` 属性，以及 `a.favoriteFoods` 中的其他属性，并单独新增了一个 food。

这样就实现了 Immutable 数据，因为没有发生变更的数据都直接复用了，而且变更节点的祖先节点都变成了新的值。

但是这样的实现方式有几个弊端：

- 写法不优雅，当数据层级很深，数据结构复杂时，代码会变得很臃肿。
- 没有真正实现对原始类型数据的复用，实际上在进行扩展运算时，会重新创建新的原始类型数据。
- 对于数组而言，在首尾添加数据还好，但是要在指定索引修改值或者插入值的话，会变得更加复杂，需要对原始数组进行多次切割。
- 操作效率低下，对于数组而言，需要复制的节点数为 O(N)，索引越大，需要复制的节点数越多。

#### 2 链表

通过链表实现数据结构的共享大家可能也比较熟悉，因为和 git 的分支实现原理非常类似。通过使用不同的头指针指向不同的链表节点，可以实现数据结构的持久化：

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gixidk26qvj31ps0lkjt4.jpg)

如上图，我们如果要将 HEAD1 指向的节点 shift，只需要创建一个新的指针 HEAD2 指向第二个节点，这样就共享了 2 - 3 - 4 节点。

这时候如果我们要 unshift 一个新的节点，只需要创建一个新的节点，让新的头指针 HEAD3 指向它，然后将新的节点指向原来的 HEAD2 节点即可，这样又实现了 2 - 3 - 4 节点的复用。

如果我们要将 HEAD3 链表移除 2 节点，只需要复制 1‘ 节点，然后将其指向 3 节点，并且创建新的 HEAD4 头指针指向复制后的 1’‘ 节点。

所以通过链表实现 Immutable List，每次操作过程中可能需要复制的节点是被修改节点的左边所有节点，右边的节点都可以被共享。

但是这种实现方式的缺陷也是显而易见的：

- 存储效率低下（50%），每个节点只能存储一个数据和一个指针。
- 随机索引效率低下，需要从头遍历节点进行查找。

为了解决第一个缺陷，引入了一个新的数据结构：串。

#### 3 串

串是数组和链表的结合，将每个链表节点存储的数据从一个变成了多个。

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gixiq5sen3j31u0088mxr.jpg)

实现原理同链表，但是空间存储效率提高了。

但是缺陷仍然是随机索引效率较低。为了解决这个问题，我们考虑用平衡二叉树实现持久化数据结构。

#### 4 平衡二叉树

![](https://tva1.sinaimg.cn/large/007S8ZIlgy1gixisyx3ljj319e0lwn1g.jpg)

平衡二叉树左右节点均衡，高度差不会超过 1，所以针对不同长度的索引，操作/查找数据的时间复杂度以及需要复制的节点数非常稳定，均为 O(logN)。这样就大大提高了数据结构时间复杂度的稳定性，而且树的随机索引能力比链表强很多。

但是平衡二叉树也有自身的缺陷，就是空间存储效率极低，每个节点只能存储一个数据，但是需要存储两份指针。但是平衡二叉树给了我们很好的启发，通过树实现持久化数据结构，可以尽可能少且稳定的复制一定数量的节点。

结合数组和树，可以实现最适合持久化数据结构的 Vector Trie。

#### 5 Vector Trie



